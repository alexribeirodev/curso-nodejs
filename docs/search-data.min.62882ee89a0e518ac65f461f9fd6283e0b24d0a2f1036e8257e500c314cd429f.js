(function(){const pages=[{"idx":0,"href":"/curso-nodejs/docs/overview-javascript/console/","title":"Console","content":" Console Um dos processos mais utilizados nas linguagens de programação para se debugar um algoritmo é através impressões (mais conhecidos como \u0026ldquo;print\u0026rdquo;), geralmente a nível console/terminal, do que desejamos ver do fluxo de execução, podendo ser desde fluxos de entrada, saída e erros.\nEssa impressão difere entre as linguagens em questão de sintaxe, mas sua mecânica não costuma ser diferente. Abaixo temos listadas alguns exemplos desse tipo de impressão em algumas linguagens.\nJava:\nSystem.out.println(\u0026quot;Hello World!\u0026quot;);  C#:\nConsole.Write(\u0026quot;Hello World!\u0026quot;);  Python:\nprint(\u0026quot;Hello World!\u0026quot;)  No Javascript, essa responsabilidade fica sobre o objeto console, que fornece acesso ao console de debug do navegador incluindo um conjunto de ferramentas.\nHello World! Agora já podemos executar nosso primeiro e clássico Hello World utilizando este objeto do Javascript. Para isso, acesse qualquer página web em um navegador de sua preferência, clique com o botão direito sobre qualquer lugar da página e procure a opção Inspecionar. Notará que abriu uma nova camada no navegador, nela acesse a aba Console. Este será nosso primeiro playground para Javascript.\nCopie o código abaixo, cole no console e tecle Enter:\nconsole.log(\u0026quot;Hello World!\u0026quot;)  Parabéns! Você executou seu primeiro trecho de código em Javascript.\nSaiba mais O objeto console possui diversas outras ferramentas complementares ao ´console.log´, clique aqui para saber mais.\n"},{"idx":1,"href":"/curso-nodejs/docs/node/gerenciando-dependencias/","title":"Gerenciando pacotes e dependências com NPM","content":" Gerenciando pacotes e dependências com NPM Package.json "},{"idx":2,"href":"/curso-nodejs/docs/introducao/","title":"Introdução","content":""},{"idx":3,"href":"/curso-nodejs/docs/introducao/o-que-e-node/","title":"O que é Node.js?","content":" O que é Node.js? Node.js é um runtime de JavaScript, criado por Ryan Dahl em 2009. Foi desenvolvido em cima do motor JavaScript V8 — engine criada pelo Google e utilizado no Chrome e Chromium, desenvolvida na linguagem C++ — , que leva o processamento e renderização do JavaScript para o lado do servidor.\nNode.js usa um modelo de I/O não bloqueante orientada a evento que o torna leve e eficiente, que possibilita criar aplicações rápidas, escaláveis e estáveis. Desde seu surgimento, vem ganhando crescente espaço entre profissionais de tecnologia do Brasil e do mundo.\nJá pensou, poder utilizar javascript no back-end, com a mesma segurança proporcionada por linguagens como PHP e ASP.NET?!\nPara quem já tem certa experiência com desenvolvimento web (certamente conhece a limitação de uso do Javascript no front-end) nunca iria imaginar essa possibilidade.\nAgora estamos em uma era diferente, onde praticamente todas as grandes limitações do Javascript não existem mais. A cada dia infinitas possibilidades surgem e diversas referências vem aderindo a esse avanço.\nPor que (e quando) utilizar Node.js? Vou listar pontos cruciais, alguns já mencionados anteriormente, que irão te esclarecer o porquê de utilizar o Node.js:\n Assíncrono ; I/O sem bloqueios ; Alta performance ; Escalabilidade fácil e barata ; Loop de eventos.  Um detalhe que toma a dianteira em relação aos concorrentes é o loop de eventos. Irei explicar melhor como isso funciona.\nGeralmente, um jeito “tradicional” de lidar com muitas requisições é criando múltiplas threads, ou seja, para cada requisição é criada uma thread. Nela é tratada a requisição e somente após o retorno deste tratamento a thread é finalizada. Porém, muito recurso é gasto nesse processo e muitas vezes de forma desnecessária, já que nem sempre todo aquele recurso reservado é utilizado e a thread fica “estacionada” enquanto o tratamento não estiver concluído.\n Quando uso o termo “tratamento” me refiro a qualquer processo feito antes de devolver uma resposta, seja uma consulta no banco, verificação de arquivo, cálculo…\n Já o Node.js, trata toda e qualquer requisição em uma única thread.\n Aí você me pergunta: Então como é possível ele ser tão performático?\n Quando ele recebe uma requisição, ao invés de esperar o resultado do tratamento desta, ele segue com a próxima requisição e assim por diante, como uma fila. Quando alguma requisição em espera tiver seu tratamento finalizado, é sinalizado um evento que a retornará o quanto antes. Ou seja, Node.js utiliza o que é chamado modelo de programação orientado a evento.\nIsso quer dizer que, com o Node.js, temos um ganho muito grande de número de requisições que podem ser processadas.\nNode.js não é apenas um servidor, já que hoje em dia pode ser utilizado para criar até mesmo aplicações desktop. Também é ótimo para realizar diversos tipos de projetos, como:\n APIs (principal uso); Aplicações web real-time como servidores de chat ou aplicações colaborativas entre múltiplos usuários (socket); Jogos multiplayer; Aplicações que demandam alta escalabilidade; Servidores de streaming de dados.  Quando não utilizar? Por usar somente uma thread, ele não serve para lidar com algoritmos complexos que consumam muita CPU, como edição de imagens, por exemplo. Isso impediria a execução de outras ações até o processamento estar completo.\nQuem já utiliza?  Então quer dizer que não é só uma “modinha”?\n Aqui vai uma lista de empresas conhecidas que utilização esta linda tecnologia:\n Walmart; PayPal; Groupon; Netflix; LinkedIn ; New York Times; Flickr ; Mozilla ; Yahoo..  Links Úteis  https://nodejs.org/ https://en.wikipedia.org/wiki/Ryan_Dahl https://v8.dev/ https://medium.com/reactbrasil/como-o-javascript-funciona-dentro-da-engine-v8-5-dicas-sobre-como-escrever-c%C3%B3digo-otimizado-e05af6088fd5 https://dev.to/alexribeir0_/o-que-e-node-js-4oh5 https://github.com/Webschool-io/be-mean/blob/master/Apostila/module-nodejs/pt-br/theory.md  "},{"idx":4,"href":"/curso-nodejs/docs/introducao/instalacao-node/","title":"Instalação do Node.js","content":" Instalação do Node.js Existem diversas formas de se instalar o Node.js e funciona em praticamente todas os sistemas operacionais e plataformas existentes atualmente. Daremos preferência à versão LTS (Long-term Support), pois a última versão (latest) pode possuir eventuais bugs (e de bugs, já basta os nossos rsrs).\nPara instalar, vamos acessar a página de download oficial do Node.js, clicando aqui.\nWindows  Existe as seguintes formas de se ter o Node.js instalado no Windows:\n .msi .zip Chocolatey Scoop  Todas estas formas podem ser encontrada na página oficial de download.\n Linux  Existem algumas formas de se instalar o Node.js no linux, mas a forma mais rápida é através do terminal. Por padrão, os sistemas operacionais baseados no Ubuntu já possuem alguma versão do Node.js instalada por padrão, só que vamos focar no processo manual de instalar a versão LTS.\nPara ver todas as opções de instalação no Linux por terminal basta clicar aqui.\nAbaixo temos um exemplo de instalação no Ubuntu:\n$ curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash - $ sudo apt-get install -y nodejs npm   MacOS  Para instalar no MacOs pode ser por meio de: - .pkg - .tar.gz - Homebrew - MacPorts - pkgsrc\nComo o Homebrew é um dos gerenciadores de pacotes mais utilizados para MacOS, abaixo temos um exemplo de como é feita a instalação por terminal:\n$ brew install node    Após instalação concluída, vamos validar pelo terminal a versão atual do Node.js e do NPM (Node Package Manager):\n$ node --version $ npm --version  Links Úteis  https://nodejs.org/en/download/  "},{"idx":5,"href":"/curso-nodejs/docs/node/manipulando-arquivos/","title":"Manipulando Arquivos","content":" Manipulando Arquivos "},{"idx":6,"href":"/curso-nodejs/docs/overview-javascript/","title":"Overview Javascript","content":""},{"idx":7,"href":"/curso-nodejs/docs/overview-javascript/comentarios/","title":"Comentários","content":" Comentários Comentários são essenciais em qualquer linguagem, principalmente se estiver pensando no seu coleguinha que irá tocar no código depois de você. Deixar comentários no código detalhando pelo menos para quê um item (classe, variável, função, e etc) está sendo utilizado é imprescindível para a saúde de qualquer projeto, independente do quão custoso isso possa ser.\nNo Javascript, existem duas formas de inserir comentários no código: linha única e multiplas linhas.\nExemplos com linha única utilizando //:\n// Variáveis let x = 0; // Declarando variável x let y = x + 1; // Declarando variável y  Exemplo com multiplas linhas, abrindo o bloco com /* e fechando com */:\n/* Essa classe é responsável por definir o objeto User com seus atributos e métodos */ class User { constructor(nome, sobrenome, idade) { this.nome = nome this.sobrenome = sobrenome this.idade = idade } }  Links Úteis - https://www.w3schools.com/js/js_comments.asp\n"},{"idx":8,"href":"/curso-nodejs/docs/node/json/","title":"JSON","content":" JSON "},{"idx":9,"href":"/curso-nodejs/docs/node/","title":"Node.js","content":""},{"idx":10,"href":"/curso-nodejs/docs/node/requisicoes-http/","title":"Requisições HTTP com módulo HTTP","content":" Requisições HTTP com módulo HTTP "},{"idx":11,"href":"/curso-nodejs/docs/overview-javascript/variaveis/","title":"Variáveis","content":" Variáveis Em Javascript, as variáveis possuem tipagens dinâmicas. Podemos criar uma variável atribuindo um valor do tipo inteiro e logo em seguida atribuir uma string, como o exemplo a seguir.\nvar x = 1 console.log(x) // 1 x = \u0026quot;Essa é uma string\u0026quot; console.log(x) // \u0026quot;Essa é uma string\u0026quot;  Os nomes das variáveis em Javascript são bastante flexíveis. Eles podem conter letras, números, sublinhados e cifrões. A regra aqui é que uma variável só pode começar com um caractere, um cifrão ou um sublinhado, mas nunca com um número. No entanto, é só no primeiro caractere, depois dele você pode utilizar o que quiser.\n Javascript é case-sensitive com seus identificadores.\n Operador de atribuição Em javascript, o sinal de igual (=) é um operador de atribuição, não um operador de igualdade, assim como em diversas outras linguagens.\n O operador de igualdade é escrito como == (ou ===, se for comparar tanto o valor quanto seu tipo).\n Tipos de dados Em Javascript, todas as estrutura são objetos. Ainda assim, existem os tipos de dados abaixo:\n Strings — Uma String nada mais é que texto puro. Numbers — São os números, seja eles integer, float, double etc. Booleans — São os operadores booleanos (true ou false) Arrays — É uma estrutura de dado para armazenar uma coleção de valores, sendo eles de qualquer tipo. Objects — Conjunto de atributos aninhados a uma variável denomina-se um objeto. Functions — Em JavaScript é possível declarar uma variável como uma função, podendo fazer operações e retornando o valor para a variável de declaração. Obs: muito utilizado no paradigma de programação funcional.  Tipos de declarações Podemos fazer a declaração de uma variável no Javascript com três operadores: var, let e const. Ambos servem para o mesmo fim, armazenar valores de dados, porém possuem usabilidades distintas. O que diferencia uma da outra gira em torno ou de escopo ou de mutabilidade dos dados.\nconst Utilize quando você precisar declarar constantes, ou seja, você não quer haja uma nova atribuição de valor para uma variável durante a execução do bloco. O escopo das variáveis declaradas com const será o bloco em que elas foram declaradas. Além de que esta, ao contrário das outras, deve ter sempre um valor atribuído logo quando inicializada.\nvar Utilize quando precisar declarar uma variável que deve ser global dentro do seu contexto de execução, ou seja, o valor dessa variável poderá ser alterado a qualquer momento em qualquer bloco que esteja dentro do mesmo contexto de execução. Dito isto, o escopo dos identificadores definidos com var é o contexto de execução em que foram declarados, se a variável foi declarada dentro de uma função, seu escopo será aquela função, se não foi declarado dentro de nenhuma função, seu escopo será global.\nlet Utilize quando você precisar fazer reatribuições, ou seja, a sua variável precisará assumir diferentes valores durante a execução do bloco. Assim como const, o escopo das variáveis definidas com let será o bloco em que foram declaradas.\n"},{"idx":12,"href":"/curso-nodejs/docs/overview-javascript/objetos/","title":"Objetos","content":" Objetos Utilizando Javascript, existem varias formas de se construir um objeto. Utilizando JavaScript, existem varias formas de se construir um objeto. As três formas mais conhecidas são: utilizando a notação literal, utilizando funções construtoras e classes (esta será abordada em outro tópico).\nUm objeto é composto por um conjunto de chaves e valores, estes podendo ser desde string à functions, entre duas chaves ({}). Suponha o seguinte exemplo de função construtora:\nlet Pessoa = function(nome, email) { this.nome = nome; // verifica se o e-mail foi preenchido if (email) { this.email = email; } }; let joao = new Pessoa(\u0026quot;João da Silva\u0026quot;, \u0026quot;joao@da.silva\u0026quot;); // criando nova pessoa, object console.log(joao.nome); // João da Silva console.log(joao.email); // joao@da.silva  E abaixo um exemplo com a criação literal:\nlet joao = { nome: \u0026quot;João da Silva\u0026quot;, email: \u0026quot;joao@da.silva\u0026quot; }  Links Úteis  https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Guide/Trabalhando_com_Objetos https://developer.mozilla.org/pt-BR/docs/Aprender/JavaScript/Objetos/B%C3%A1sico  "},{"idx":13,"href":"/curso-nodejs/docs/node/requisicoes-request/","title":"Requisições HTTP com módulo Request","content":" Requisições HTTP com módulo Request "},{"idx":14,"href":"/curso-nodejs/docs/node/servidor-http/","title":"Criando um servidor HTTP com módulo HTTP","content":" Criando um servidor HTTP com módulo HTTP "},{"idx":15,"href":"/curso-nodejs/docs/overview-javascript/funcoes/","title":"Funções","content":" Funções Segundo a descrição da mozilla.org:\n Funções são blocos de construção fundamentais em JavaScript. Uma função é um procedimento de JavaScript — um conjunto de instruções que executa uma tarefa ou calcula um valor. Para usar uma função, você deve defini-la em algum lugar no escopo do qual você quiser chamá-la.\n Funções em Javascript são conhecidas como objetos de primeira classe (first-class objects). Isso porque tudo o que você pode fazer com um objeto, você pode fazer com funções. Na realidade uma função é um objeto do tipo Function.\nAs funções podem ser utilizadas de diversas formas, estas às quais iremos abordar a seguir.\nCriadas de forma literal function myFunction(){} //definindo uma função  Passadas como parâmetros para outras funções function myFunction(param){} //definindo a função //invocando a função e passando como parâmetro outra função myFunction(function(){ console.log(\u0026quot;função como parâmetro\u0026quot;) })  Atribuídas para propriedades de objetos //definindo um objeto com uma propriedade que é uma função let obj = { start:function(){} }; //atribuindo uma função como propriedade para um objeto dinamicamente let obj = {}; obj.myFunction = function(){};  Retornadas como resultado de uma função function myFunction(){ return function(){} //retornando uma função como resultado }  Possuir propriedades que podem ser atribuídas dinamicamente function myFunction(){} myFunction.startTime = 0 // atribuindo uma propriedade para a função // a forma abaixo também funciona let myFunction = function(){} myFunction.startTime = 0   Exemplos retirados de uma postagem, do blog React Brasil, muito completa sobre o tema.\n Principais formas de definir funções Arrow functions Arrow functions é uma forma mais simplificada e direta de se criar uma function e foi adicionada no ES6. Esta forma de se escrever uma função também é encontrada em outras linguagens.\n// arrow function em apenas uma linha e sem o return let sum = (x, y) =\u0026gt; x + y sum(1, 1) //arrow function com bloco de código let sum = (x, y) =\u0026gt; { return x + y } sum(1, 1)  Callback functions Uma callback function (chaamda de retorno) é uma função que é passada como argumento para outra função, para ser \u0026ldquo;chamada de volta\u0026rdquo; posteriormente. Uma função que aceita outras funções como argumentos é chamada de função de higher-order (ordem superior), que contém a lógica para quando a callback function é executada. É a combinação desses dois que nos permite ampliar nossa funcionalidade.\nVeja o exemplo abaixo:\nfunction createQuote(quote, callback){ let myQuote = \u0026quot;Como eu sempre digo, \u0026quot; + quote; callback(myQuote); // 2 } function logQuote(quote){ console.log(quote); } createQuote(\u0026quot;coma seus vegetais!\u0026quot;, logQuote); // 1 // Resultado no console: // Como eu sempre digo, coma seus vegetais!  Links Úteis  https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Guide/Fun%C3%A7%C3%B5es https://www.ecma-international.org/ecma-262/6.0/#sec-function-definitions  "},{"idx":16,"href":"/curso-nodejs/docs/node/expressjs/","title":"Conhecendo o Express.js","content":" Conhecendo o Express.js Criando uma API com Express.js Estruturando no padrão MVC Criando gerenciamento de rotas Conhecendo Middlewares "},{"idx":17,"href":"/curso-nodejs/docs/node/servicos-aws/","title":"Consumindo Serviços da AWS","content":" Consumindo Serviços da AWS "},{"idx":18,"href":"/curso-nodejs/docs/overview-javascript/contexto/","title":"Contexto (this)","content":" Contexto (this) O contexto no Javacript é algo que tanto pode ser tanto nosso amigo quanto nosso pior inimigo. O mesmo é responsável muitas vezes o motivo de bugs em nosso algoritmo, como também a solução para muitos de nossos problemas.\nO contexto pode ser acessado de qualquer parte do seu código pelo objeto reservado this. Porém, seu valor pode ser diferente dependendo de qual parte do seu código está sendo chamado.\nO contexto é todo o escopo que determinada função, método, objeto ou variável está inserida.\nVamos entender melhor no exemplo abaixo:\nvar nome = 'joao' function dizerFrase(){ console.log(this.nome + \u0026quot; é meu nome!\u0026quot;) } dizerFrase() // joao é meu nome! let pessoa = { nome: 'Fulano', dizerFrase: function (){ console.log(`${this.nome} é meu nome!`) } } pessoa.dizerFrase() // Fulano é meu nome!  Como podemos ver, o primeiro this pegou o escopo global, enquanto que o seguindo this pegou o escopo do objeto ao qual se encontrava, mesmo que o parâmetro seja igual.\nArrow Function Um ponto muito importante a ser levado em consideração é que se utilizarmos o mesmo código acima, alterando apenas a função dizerFrase do objeto pessoa para arrow function, teremos um retorno diferente:\nvar nome = 'joao' function dizerFrase(){ console.log(this.nome + \u0026quot; é meu nome!\u0026quot;) } dizerFrase() // joao é meu nome! let pessoa = { nome: 'Fulano', dizerFrase: () =\u0026gt; { console.log(`${this.nome} é meu nome!`) } } pessoa.dizerFrase() // joao é meu nome!  O retorno se mantém com o valor da variável nome definida por fora do objeto pessoa. Isso acontece por conta de um detalhe bem peculiar do arrow function, ele considera apenas o escopo superior àquele em que está definido, diferente de uma função anônima criada com o function.\nLinks Úteis  https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Operators/this https://www.w3schools.com/js/js_this.asp https://imasters.com.br/javascript/javascript-entendendo-o-de-uma-vez-por-todas  "},{"idx":19,"href":"/curso-nodejs/docs/overview-javascript/operadores-aritmeticos/","title":"Operadores Aritméticos","content":" Operadores Aritméticos Operadores aritméticos tem valores numéricos (literais ou variáveis) como seus operadores e retornam um valor numérico único. Os operadores aritméticos padrões são adição (+), subtração (-), multiplicação (*), e divisão (/). (mozilla.org)\nAdição (+) Este operador produz a soma dos valores, estes sendo numéricos ou strings.\nExemplos:\n// Número + Número -\u0026gt; adição 1 + 2 // 3 // Booleano + Número -\u0026gt; adição true + 1 // 2 // Booleano + Booleano -\u0026gt; adição false + false // 0 // Número + String -\u0026gt; concatenação 5 + \u0026quot;foo\u0026quot; // \u0026quot;5foo\u0026quot; // String + Booleano -\u0026gt; concatenação \u0026quot;foo\u0026quot; + false // \u0026quot;foofalse\u0026quot; // String + String -\u0026gt; concatenação \u0026quot;foo\u0026quot; + \u0026quot;bar\u0026quot; // \u0026quot;foobar\u0026quot;  Subtração (-) Este operador subtrai dois valores, produzindo sua diferença.\n5 - 3 // 2 3 - 5 // -2 \u0026quot;foo\u0026quot; - 3 // NaN  Multiplicação (*) Este operador produz o produto dos operandos.\n2 * 2 // 4 -2 * 2 // -4 Infinity * 0 // NaN Infinity * Infinity // Infinity \u0026quot;foo\u0026quot; * 2 // NaN  Divisão (/) Este operador produz o quociente de seus operandos onde o operando da esquerda é o dividendo e o da direita é o divisor.\n1 / 2 // retorna 0.5 em JavaScript 1 / 2 // retorna 0 em Java // (nenhum dos números é explicitamente um número de ponto flutuante) 1.0 / 2.0 // retorna 0.5 em JavaScript e Java 2.0 / 0 // retorna Infinity em JavaScript 2.0 / 0.0 // retorna Infinity também 2.0 / -0.0 // retorna -Infinity em JavaScript  Módulo (%) Este operador produz o resto inteiro da divisão de dois valores.\n12 % 5 // 2 -1 % 2 // -1 NaN % 2 // NaN  Exponenciação (**) Eset operador retorna o resultado do primeiro operando elevado ao segundo operando.\n2 ** 3 // 8 3 ** 2 // 9 3 ** 2.5 // 15.588457268119896 10 ** -1 // 0.1 NaN ** 2 // NaN 2 ** 3 ** 2 // 512 2 ** (3 ** 2) // 512 (2 ** 3) ** 2 // 64  Incremento (++) Este operador incrementa seu operando e retorna um valor.\n// Posfixo var x = 3; y = x++; // y = 3, x = 4 // Prefixo var a = 2; b = ++a; // a = 3, b = 3  Decremento (\u0026ndash;) Este operador decrementa seu operando e retorna um valor.\n// Posfixo var x = 3; y = x--; // y = 3, x = 2 // Prefixo var a = 2; b = --a; // a = 1, b = 1  Negação Unária (-) Este operador precede seu operando e o nega.\nvar x = 3; y = -x; // y = -3, x = 3  Soma Unária (+) Este operador precede seu operando e calcula para seu operando mas tenta convertê-lo para um número, caso ainda não o seja.\n+3 // 3 +\u0026quot;3\u0026quot; // 3 +true // 1 +false // 0 +null // 0   Exemplos retirados da documentação da mozilla.org, uma das principais fontes de conteúdo sobre javascript.\n "},{"idx":20,"href":"/curso-nodejs/docs/overview-javascript/listas-arrays/","title":"Array","content":" Array O objeto Array do JavaScript é um objeto global usado na construção de \u0026lsquo;arrays\u0026rsquo;: objetos de alto nível semelhantes a listas.\nCriando um Array const frutas = ['Maçã', 'Banana']; console.log(frutas.length); // 2  Acessar um item (index) do Array const primeiro = frutas[0]; // Maçã const ultimo = frutas[frutas.length - 1]; // Banana  Métodos Modificadores Um objeto do tipo Array possui métodos que podem ser utilizados para modificar sua estrutura. Vejamos alguns deles abaixo.\nForEach Executa uma dada função em cada elemento de um array.\nfunction logArrayElements(element, index, array) { console.log(\u0026quot;a[\u0026quot; + index + \u0026quot;] = \u0026quot; + element); } [2, 5, 9].forEach(logArrayElements); // logs: // a[0] = 2 // a[1] = 5 // a[2] = 9  Map Invoca a função callback passada por argumento para cada elemento do Array e devolve um novo Array como resultado.\nconst numbers = [1, 4, 9]; let doubles = numbers.map(function(num, index, arr) { return num * 2; }); // doubles é agora [2, 8, 18]. numbers ainda é [1, 4, 9]  Filter Cria um novo array com todos os elementos que passaram no teste implementado pela função fornecida.\nfunction isBigEnough(value, index, arr) { return value \u0026gt;= 10; } let filtered = [12, 5, 8, 130, 44].filter(isBigEnough); // filtrado é [12, 130, 44]  Push Adiciona um ou mais elementos ao final de um array e retorna o novo comprimento desse array.\nconst numeros = [1, 2, 3]; numeros.push(4); console.log(numeros); // [1, 2, 3, 4] numeros.push(5, 6, 7); console.log(numeros); // [1, 2, 3, 4, 5, 6, 7]  Pop Remove o último elemento de um array e retorna aquele elemento.\nconst meuPeixe = ['acara-bandeira', 'palhaco', 'mandarim', 'esturjao']; console.log(meuPeixe); // ['acara-bandeira', 'palhaco', 'mandarim', 'esturjao'] const meuPeixePop = meuPeixe.pop(); console.log(meuPeixe); // ['acara-bandeira', 'palhaco', 'mandarim' ] console.log(meuPeixePop); // 'esturjao'  Shift Remove o primeiro elemento de um array e retorna esse elemento.\nconst minhaLista = ['anjo', 'casa', 'mandarim', 'medico']; console.log('minhaLista antes: ' + minhaLista); // minhaList antes: ['anjo', 'casa', 'mandarim', 'medico'] const shifted = minhaLista.shift(); console.log('minhaLista depois: ' + minhaLista); // minhaList depois: ['casa', 'mandarim', 'medico'] console.log('Elemento removido: ' + shifted); // Elemento removido: anjo  UnShift Adiciona um ou mais elementos no início de um array e retorna o número de elementos (propriedade length) atualizado.\nconst arr = [1, 2]; arr.unshift(0); // result of call is 3, the new array length // arr is [0, 1, 2] arr.unshift(-2, -1); // = 5 // arr is [-2, -1, 0, 1, 2] arr.unshift([-3]); // arr is [[-3], -2, -1, 0, 1, 2]  Indexof Retorna o primeiro índice em que o elemento pode ser encontrado no array, retorna -1 caso o mesmo não esteja presente.\nconst indices = []; const array = ['a', 'b', 'a', 'c', 'a', 'd']; const elemento = 'a'; let idx = array.indexOf(elemento); while (idx != -1) { indices.push(idx); idx = array.indexOf(elemento, idx + 1); } console.log(indices); // [0, 2, 4]  Splice Altera o conteúdo de uma lista, adicionando novos elementos enquanto remove elementos antigos.\nconst myFish = [\u0026quot;angel\u0026quot;, \u0026quot;clown\u0026quot;, \u0026quot;mandarin\u0026quot;, \u0026quot;surgeon\u0026quot;]; //remove 0 elementos a partir do índice 2, e insere \u0026quot;drum\u0026quot; let removed = myFish.splice(2, 0, \u0026quot;drum\u0026quot;); //myFish é [\u0026quot;angel\u0026quot;, \u0026quot;clown\u0026quot;, \u0026quot;drum\u0026quot;, \u0026quot;mandarin\u0026quot;, \u0026quot;surgeon\u0026quot;] //removed é [], nenhum elemento removido //remove 1 elemento do índice 3 removed = myFish.splice(3, 1); //myFish é [\u0026quot;angel\u0026quot;, \u0026quot;clown\u0026quot;, \u0026quot;drum\u0026quot;, \u0026quot;surgeon\u0026quot;] //removed é [\u0026quot;mandarim\u0026quot;] //remove 1 elemento a partir do índice 2, e insere \u0026quot;trumpet\u0026quot; removed = myFish.splice(2, 1, \u0026quot;trumpet\u0026quot;); //myFish é [\u0026quot;angel\u0026quot;, \u0026quot;clown\u0026quot;, \u0026quot;trumpet\u0026quot;, \u0026quot;surgeon\u0026quot;] //removed é [\u0026quot;drum\u0026quot;] //remove 2 elementos a partir do índice 0, e insere \u0026quot;parrot\u0026quot;, \u0026quot;anemone\u0026quot; e \u0026quot;blue\u0026quot; removed = myFish.splice(0, 2, \u0026quot;parrot\u0026quot;, \u0026quot;anemone\u0026quot;, \u0026quot;blue\u0026quot;); //myFish é [\u0026quot;parrot\u0026quot;, \u0026quot;anemone\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;trumpet\u0026quot;, \u0026quot;surgeon\u0026quot;] //removed é [\u0026quot;angel\u0026quot;, \u0026quot;clown\u0026quot;] //remove 2 elementos a partir do indice 3 removed = myFish.splice(3, Number.MAX_VALUE); //myFish é [\u0026quot;parrot\u0026quot;, \u0026quot;anemone\u0026quot;, \u0026quot;blue\u0026quot;] //removed é [\u0026quot;trumpet\u0026quot;, \u0026quot;surgeon\u0026quot;]  Slice Retorna uma cópia de parte de um array a partir de um subarray criado entre as posições início(begin) e fim(end)(fim não é necessário) de um array original. O Array original não é modificado.\n// Exemplo extrair nossos bons amigos, os cítricos, das frutas const frutas = ['Banana', 'Laranja', 'Limao', 'Maçã', 'Manga']; const citricos = frutas.slice(1, 3); // citricos contem ['Laranja','Limao']  "},{"idx":21,"href":"/curso-nodejs/docs/overview-javascript/condicionais/","title":"Condicionais","content":" Condicionais if\u0026hellip;else Ternário switch "},{"idx":22,"href":"/curso-nodejs/docs/overview-javascript/loops/","title":"Loops","content":" Loops For ForIn ForOf While Break e Continue "},{"idx":23,"href":"/curso-nodejs/docs/overview-javascript/prototype/","title":"Prototype","content":" Prototype "},{"idx":24,"href":"/curso-nodejs/docs/overview-javascript/classes/","title":"Classes","content":" Classes "},{"idx":25,"href":"/curso-nodejs/categories/","title":"Categories","content":""},{"idx":26,"href":"/curso-nodejs/docs/","title":"Docs","content":""},{"idx":27,"href":"/curso-nodejs/","title":"Início","content":" Bem vindo ao curso de Node.js! Aqui encontrará todo o conteúdo que precisa para que possa começar a atuar com essa linda tecnologia, Node.js.\n"},{"idx":28,"href":"/curso-nodejs/tags/","title":"Tags","content":""}];window.bookSearch={pages:pages,idx:lunr(function(){this.ref("idx");this.field("title");this.field("content");pages.forEach(this.add,this);}),}})();